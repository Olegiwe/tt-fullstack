## Домашнее задание 9

Пример работы демона, разобранного на лекции:
https://github.com/toshunster/tehnotrack/tree/master/flask
Смотри daemon.py и метод url_viewer в app/views.py.

### Создание микросервиса

Подумайте, какой дополнительный функционал Вы бы хотели прикрутить к мессенджеру.
Если идей нет, то идея такая: пользователь в теле сообщения может послать урл,
выцепляете этот урл, и посылаете на микросервис, который скачивает содержимое урла
выцепляет тривиально заголовок (og:title), описание (og:description) и картинку (og:image).
И возвращает в формате json клиенту (Flask-приложение).

Особенности демона:
# Демон должен быть автономным, в идеале располагаться на другой машине;
# Можно установить TCP соединение по порту и хосту и общаться с микросервисом или с помощью gunicorn'а но уже по http (вспоминаем 1-ую Л.Р. первого семестра).
# Все параметры демона (номер порта и т.д.) демон считывает из конфига, который подаётся ему первым аргументом. Можно использовать библиотеку парсинга configparser.

### Асинхронный вызов

Рассмотрим синхронную работу.
# Flask-приложение получает входящий запрос на добавление сообщения в чат;
# Парсится сообщение и выцепляются все урлы;
# Урл посылается на микросервис, дожидается ответа;
# Возращает ответ клиенту.

В результате сетевых задержек возможны случаи, когда третий пункт будет длится достаточно долго. В таких случаях можно сделать вызов асинхронным (см. asyncio). То есть теперь мы должны отправить микросервису урл, вернуть клиенту ответ, а когда микросервис нам ответит отрисовать на клиенте.

### Добавление микросервиса в docker

